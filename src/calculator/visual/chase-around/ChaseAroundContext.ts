import { freeze } from "immer";
import _ from "lodash";
import { Contour } from "../Contour";
import { Scale } from "../Scale";

import type { Path } from "@mattj65817/util-js";
import type { Chase } from "./chase-around-types";

/**
 * {@link ChaseAroundContext} holds context used to perform a calculation based on a chase-around chart.
 */
export class ChaseAroundContext {

    /**
     * Current position in the solution.
     *
     * @private
     */
    private readonly path: Path = [];

    /**
     * Contours followed in the solution.
     */
    public readonly solution: Contour[] = [];

    /**
     * Limit contours (scales) which affected the solution.
     */
    public readonly scales: Contour[] = [];

    /**
     * Unresolved contours, which are those generated by chase steps with no `until` condition.
     */
    public readonly unresolved: Contour[] = [];

    /**
     * Outputs produced by the calculation.
     */
    public outputs: Record<string, number> = {};

    private constructor(public readonly inputs: Record<string, number>) {
    }

    get hasPosition() {
        return !_.isEmpty(this.path);
    }

    get position() {
        const { path } = this;
        if (_.isEmpty(path)) {
            throw Error("Position not set.");
        }
        return _.last(path)!;
    }

    /**
     * Resolve the endpoint of any unresolved contours based on the start point of a given contour.
     *
     * @param along the contour whose start point is to be used.
     */
    public resolve(along: Contour) {
        const { unresolved } = this;
        if (!_.isEmpty(unresolved)) {
            const { solution, path } = this;
            const { path: [start] } = along;
            const top = unresolved.pop()!;

            /* ISS (maybe): https://github.com/mattj65817/aviation-js/issues/2 */
            if (!top.contains(start)) {
                solution.push(top);
                path.push(_.last(top.path)!);
            } else {
                const contour = top.split(start)[0];
                solution.push(contour);
                path.push(_.last(contour.path)!);
            }
        }
        return this;
    }

    /**
     * Evaluate a `chase` step, moving the current position and adding contours to the solution as appropriate.
     *
     * @param step the step.
     * @param along the chased contour.
     * @param scales the limit contour(s) if any, which ended the segment.
     */
    public chase(step: Chase, along: Contour, scales: Contour[]) {
        const { solution, hasPosition, unresolved, path } = this;
        if (hasPosition) {
            along = along.split(this.position)[1];
        }
        if (null == step.until) {
            unresolved.push(along);
        } else {
            solution.push(along);
            path.push(_.last(along.path)!);
        }
        this.scales.push(...scales);
        return this;
    }

    /**
     * Solve a variable using a scale and the current position.
     *
     * @param scale the scale.
     */
    public solve(scale: Scale) {
        const { solution, position } = this;
        solution.push(scale.through(position).split(position)[1]);
        this.outputs[scale.variable] = scale.value(position);
        return this;
    }

    /**
     * Create a {@link ChaseAroundContext} instance.
     *
     * @param inputs the input variables.
     */
    static create(inputs: Record<string, number>) {
        return freeze(new ChaseAroundContext(_.cloneDeep(inputs)), true);
    }
}
